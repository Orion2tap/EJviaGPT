# 05 Prefer dependency injection to hardwiring resources

## Common

## Main

### Pass a resource

```java
// Static utility classes and singletons are inappropriate for classes whose behavior is parameterized by an underlying resource.

// A simple pattern that satisfies this requirement is to pass the resource (connection) into the constructor (DatabaseManager) when creating a new instance.

public class DatabaseManager {
    private final Connection connection;

    public DatabaseManager(Connection connection) {
        this.connection = connection;
    }

    public void executeQuery(String query) {
        // Execute a database query
        // ...
    }

    // Other database operation methods...
}

```

```java
// call

// This is one form of dependency injection: the connection is a dependency of the DatabaseManager and is injected into the DatabaseManager when it is created.

// JDBC Demo
public class Main {

    public static void main(String[] args) {
        // Define the database connection details
        String url = "jdbc:mysql://localhost:3306/mydatabase";
        String username = "Orion2tap";
        String password = "123456";

        try (Connection connection = DriverManager.getConnection(url, username, password)) {
            // Create an instance of DatabaseManager and pass the connection object
            DatabaseManager dbManager = new DatabaseManager(connection);
            
            // Execute a database query
            dbManager.executeQuery("SELECT * FROM table_name");
            
            // Perform other database operations...
        } catch (SQLException e) {
            // Handle any SQL-related exceptions
            e.printStackTrace();
        }
    }
}

```

### Dependency injection - Pro 1 & 2

```java
// Dependency injection preserves immutability (Item 17), so multiple clients can share dependent objects (assuming the clients desire the same underlying resources).
```

```java
class DataSource {
    // Implementation of data source
}

class ReportGenerator {
    // Immutability 
    private final DataSource dataSource;

    public ReportGenerator(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    public void generateReport() {
        // Generate report using the dataSource
    }
}

class Client1 {
    private final ReportGenerator reportGenerator;

    public Client1(ReportGenerator reportGenerator) {
        this.reportGenerator = reportGenerator;
    }

    public void doSomething() {
        // Use the reportGenerator to generate a report
        reportGenerator.generateReport();
        // ...
    }
}

class Client2 {
    private final ReportGenerator reportGenerator;

    public Client2(ReportGenerator reportGenerator) {
        this.reportGenerator = reportGenerator;
    }

    public void doSomethingElse() {
        // Use the report generator to generate a report
        reportGenerator.generateReport();
        // ...
    }
}
```

```java
// call

public class Main {
    public static void main(String[] args) {
        // Create a DataSource object
        DataSource dataSource = new DataSource();

        // Use dependency injection to create a ReportGenerator
        ReportGenerator reportGenerator = new ReportGenerator(dataSource);

        // Create Client1 and Client2, sharing the same ReportGenerator
        Client1 client1 = new Client1(reportGenerator);
        Client2 client2 = new Client2(reportGenerator);

        // Client1 generates a report
        client1.doSomething();

        // Client2 generates a report
        client2.doSomethingElse();
    }
}

```

### Pass a resource factory

